use std::collections::HashMap;
use std::fs;
use std::io::{self, Write};

use rcx_pi_rust::{
    engine::Engine,
    formatter::{bucket_to_string, mu_to_string},
    mu_loader::{load_mu_file, save_mu_file},
    orbit::orbit,
    parser::parse_mu,
    serialize::{load_state, save_state},
    serialize_json,
    state::RCXState,
    trace::RouteKind,
    types::{Mu, RcxProgram, RcxRule, RuleAction},
};

/// Classify an orbit purely from its state sequence.
/// This is local to the REPL and does *not* depend on orbit::OmegaKind.
fn classify_orbit(seq: &[Mu]) -> String {
    if seq.is_empty() {
        return "empty orbit (no states produced)".to_string();
    }
    if seq.len() == 1 {
        return "no detected cycle up to 1 steps".to_string();
    }

    // 1) Try "pure cycle from the seed" detection.
    let seed = &seq[0];
    let mut found_period: Option<usize> = None;

    for i in 1..seq.len() {
        if &seq[i] == seed {
            found_period = Some(i);
            break;
        }
    }

    if let Some(period) = found_period {
        // Verify that the whole sequence respects this period.
        let mut pure = true;
        for (idx, mu) in seq.iter().enumerate() {
            if mu != &seq[idx % period] {
                pure = false;
                break;
            }
        }

        if pure {
            if period == 1 {
                return "fixed point".to_string();
            } else {
                return format!("pure limit cycle (period = {period})");
            }
        }
    }

    // 2) Fallback: transient + cycle detection using last state (your current logic, but with rposition).
    let last = &seq[seq.len() - 1];

    if let Some(prev_idx) = seq[..seq.len() - 1].iter().rposition(|m| m == last) {
        let transient_len = prev_idx;
        let period = seq.len() - 1 - prev_idx;

        if period == 1 {
            if transient_len == 0 {
                "fixed point".to_string()
            } else {
                format!("transient of length {transient_len} then fixed point")
            }
        } else if transient_len == 0 {
            format!("pure limit cycle (period = {period})")
        } else {
            format!("transient of length {transient_len} then limit cycle (period = {period})")
        }
    } else {
        format!("no detected cycle up to {} steps", seq.len())
    }
}

fn generate_world_doc(world_name: &str, program: &RcxProgram) -> String {
    use std::fmt::Write as _;

    let mut out = String::new();

    // Title
    let _ = writeln!(&mut out, "# World `{}`", world_name);
    let _ = writeln!(&mut out);
    let _ = writeln!(&mut out, "Autogenerated summary of the current rule set.");
    let _ = writeln!(&mut out);
    let _ = writeln!(&mut out, "## Rules");
    let _ = writeln!(&mut out);
    let _ = writeln!(&mut out, "| # | Pattern | Action |");
    let _ = writeln!(&mut out, "|---|---------|--------|");

    for (idx, rule) in program.rules.iter().enumerate() {
        let pat = mu_to_string(&rule.pattern).replace('|', "\\|");
        let action_str = match &rule.action {
            RuleAction::ToRa => "ra".to_string(),
            RuleAction::ToLobe => "lobe".to_string(),
            RuleAction::ToSink => "sink".to_string(),
            RuleAction::Rewrite(mu) => format!("rewrite({})", mu_to_string(mu)),
        }
        .replace('|', "\\|");

        let _ = writeln!(&mut out, "| {} | {} | {} |", idx, pat, action_str);
    }

    if program.rules.is_empty() {
        let _ = writeln!(&mut out);
        let _ = writeln!(&mut out, "_(no rules are currently loaded in this world)_");
    }

    out
}

/// Render a RuleAction into a concise string form, suitable for diffs.
fn action_to_string(action: &RuleAction) -> String {
    match action {
        RuleAction::ToRa => "ra".to_string(),
        RuleAction::ToLobe => "lobe".to_string(),
        RuleAction::ToSink => "sink".to_string(),
        RuleAction::Rewrite(mu) => format!("rewrite({})", mu_to_string(mu)),
    }
}

/// Build a pattern -> action map for a world.
/// If multiple rules share the same pattern, the last one wins.
/// (Our worlds normally avoid that anyway.)
fn world_rule_map(program: &RcxProgram) -> HashMap<String, String> {
    let mut map = HashMap::new();
    for rule in &program.rules {
        let pat = mu_to_string(&rule.pattern);
        let act = action_to_string(&rule.action);
        map.insert(pat, act);
    }
    map
}

/// Compare two worlds by name and print a minimal diff.
fn diff_worlds(a_name: &str, b_name: &str) {
    let a_prog = match load_mu_file(a_name) {
        Ok(p) => p,
        Err(e) => {
            println!("[diff-world] error loading {}: {}", a_name, e);
            return;
        }
    };

    let b_prog = match load_mu_file(b_name) {
        Ok(p) => p,
        Err(e) => {
            println!("[diff-world] error loading {}: {}", b_name, e);
            return;
        }
    };

    let map_a = world_rule_map(&a_prog);
    let map_b = world_rule_map(&b_prog);

    let mut only_a: Vec<(String, String)> = Vec::new();
    let mut only_b: Vec<(String, String)> = Vec::new();
    let mut conflicts: Vec<(String, String, String)> = Vec::new();

    // Rules present in A
    for (pat, act_a) in &map_a {
        match map_b.get(pat) {
            None => {
                only_a.push((pat.clone(), act_a.clone()));
            }
            Some(act_b) if act_b != act_a => {
                conflicts.push((pat.clone(), act_a.clone(), act_b.clone()));
            }
            _ => {
                // same pattern, same action -> not interesting for diff
            }
        }
    }

    // Rules only in B
    for (pat, act_b) in &map_b {
        if !map_a.contains_key(pat) {
            only_b.push((pat.clone(), act_b.clone()));
        }
    }

    println!("Comparing worlds: {}  vs  {}", a_name, b_name);

    if only_a.is_empty() && only_b.is_empty() && conflicts.is_empty() {
        println!(
            "[diff-world] {} and {} are identical ({} rules each)",
            a_name,
            b_name,
            map_a.len()
        );
        return;
    }

    if !only_a.is_empty() {
        println!("\nRules only in {}:", a_name);
        for (pat, act) in &only_a {
            println!("    {} -> {}", pat, act);
        }
    }

    if !only_b.is_empty() {
        println!("\nRules only in {}:", b_name);
        for (pat, act) in &only_b {
            println!("    {} -> {}", pat, act);
        }
    }

    if !conflicts.is_empty() {
        println!("\nRules with same pattern but different actions:");
        for (pat, act_a, act_b) in &conflicts {
            println!("    {}  {}={}    {}={}", pat, a_name, act_a, b_name, act_b);
        }
    }
}

fn default_news_program() -> RcxProgram {
    RcxProgram {
        rules: vec![
            RcxRule {
                pattern: Mu::Node(vec![
                    Mu::Sym("news".to_string()),
                    Mu::Sym("stable".to_string()),
                ]),
                action: RuleAction::ToRa,
            },
            RcxRule {
                pattern: Mu::Node(vec![
                    Mu::Sym("news".to_string()),
                    Mu::Sym("unstable".to_string()),
                ]),
                action: RuleAction::ToLobe,
            },
            RcxRule {
                pattern: Mu::Node(vec![
                    Mu::Sym("news".to_string()),
                    Mu::Sym("paradox".to_string()),
                ]),
                action: RuleAction::ToSink,
            },
        ],
    }
}

fn main() {
    // Boot with default NEWS program.
    let mut program = default_news_program();
    let mut engine = Engine::new(program.clone());
    let mut state = RCXState::new();

    println!("RCX-π REPL — Mu → [r_a | lobes | sink]");
    println!("Commands:");
    println!("  <mu>             evaluate expression (e.g. A, [A,A], [news,stable])");
    println!("  :load FILE       load rules from ./mu_programs/FILE (merge into program)");
    println!("  :rules           list current program rules");
    println!("  :why MU          show trace for classifying MU");
    println!("  :learn ...       learn a rule, e.g. `:learn ping rewrite pong`");
    println!("  :orbit MU [n]    show rewrite orbit for MU up to n steps");
    println!("  :omega MU [n]    summarize ω-limit behavior for MU");
    println!("  :worlds          list available .mu worlds");
    println!("  :save-world NAME save current rules as mu_programs/NAME.mu");
    println!("  :load-world NAME reset + load mu_programs/NAME.mu as the world");
    println!("  :diff-world A B  compare rules of two worlds");
    println!("  :doc-gen NAME    generate docs/worlds/NAME.auto.md from current rules");
    println!("  :save-state NAME save rules + buckets to snapshots/NAME.state");
    println!("  :load-state NAME load rules + buckets from snapshots/NAME.state");
    println!("  :merge-lobes     move all lobes into r_a (with trace)");
    println!("  :export-json NAME  save rules to worlds_json/NAME.json");
    println!("  :trace           dump trace log");
    println!("  :clear           reset state (r_a, lobes, sink, trace)");
    println!("  :reset           reset rules + state to default NEWS world");
    println!("  :export-json NAME  save rules to worlds_json/NAME.json");
    println!("  :import-json NAME  load rules from worlds_json/NAME.json");
    println!("  :doc-world NAME  show docs for NAME from docs/worlds/NAME.md");
    println!("  :q               exit\n");

    let stdin = io::stdin();

    loop {
        print!("rcx> ");
        io::stdout().flush().unwrap();

        let mut line = String::new();
        if stdin.read_line(&mut line).is_err() {
            println!("(input error, exiting)");
            break;
        }

        let line = line.trim();
        if line.is_empty() {
            continue;
        }

        // --- Commands -------------------------------------------------------

        // quit
        if line == ":q" || line == ":quit" || line == ":exit" {
            println!("bye.");
            break;
        }

        // :clear -> reset RA / lobes / sink / trace
        if line == ":clear" {
            state = RCXState::new();
            println!("[state cleared]");
            continue;
        }

        // :reset -> restore default NEWS program + clear state
        if line == ":reset" {
            program = default_news_program();
            engine = Engine::new(program.clone());
            state = RCXState::new();
            println!("[RESET] rules + state restored to default NEWS world");
            continue;
        }

        // :trace -> dump trace log
        if line == ":trace" {
            if state.trace.is_empty() {
                println!("[trace] (empty)");
            } else {
                println!("[trace log]");
                for evt in &state.trace {
                    println!(
                        "  step {} | phase={} | route={:?} | payload={}",
                        evt.step_index,
                        evt.phase,
                        evt.route,
                        mu_to_string(&evt.payload),
                    );
                }
            }
            continue;
        }

        // :rules -> list current rules
        if line == ":rules" {
            println!("[rules]");
            for (idx, rule) in program.rules.iter().enumerate() {
                let pat = mu_to_string(&rule.pattern);
                let tgt = match &rule.action {
                    RuleAction::ToRa => "ra".to_string(),
                    RuleAction::ToLobe => "lobe".to_string(),
                    RuleAction::ToSink => "sink".to_string(),
                    RuleAction::Rewrite(mu) => {
                        format!("rewrite({})", mu_to_string(mu))
                    }
                };
                println!("  {idx}: {pat} -> {tgt}");
            }
            continue;
        }

        // :why MU  -> run a one-off classification with fresh state + trace
        if line.starts_with(":why ") {
            let mu_src = line[5..].trim();
            if mu_src.is_empty() {
                println!("usage: :why <Mu>");
                continue;
            }

            let mu = match parse_mu(mu_src) {
                Ok(mu) => mu,
                Err(e) => {
                    println!("[why] parse error: {e}");
                    continue;
                }
            };

            let mut tmp_state = RCXState::new();
            let mut tmp_engine = Engine::new(program.clone());
            let route = tmp_engine.process_input(&mut tmp_state, mu.clone());

            println!("[why] probing {}", mu_to_string(&mu));
            println!("[why] route: {:?}", route);
            if tmp_state.trace.is_empty() {
                println!("[why] (no trace events)");
            } else {
                println!("[why] trace for this classification:");
                for evt in &tmp_state.trace {
                    println!(
                        "  step {} | phase={} | route={:?} | payload={}",
                        evt.step_index,
                        evt.phase,
                        evt.route,
                        mu_to_string(&evt.payload),
                    );
                }
            }
            continue;
        }

        // :load FILE   -> always from ./mu_programs/FILE
        if line.starts_with(":load ") {
            let filename = line[6..].trim();
            if filename.is_empty() {
                println!("usage: :load <filename.mu>");
                continue;
            }

            match load_mu_file(filename) {
                Ok(p) => {
                    let n = p.rules.len();
                    program.rules.extend(p.rules.into_iter());
                    engine = Engine::new(program.clone());
                    println!("Loaded {n} rules from mu_programs/{filename}");
                }
                Err(e) => {
                    println!("load error: {e}");
                }
            }
            continue;
        }

        // :worlds -> list available .mu files in ./mu_programs
        if line == ":worlds" {
            match fs::read_dir("mu_programs") {
                Ok(entries) => {
                    let mut names: Vec<String> = entries
                        .filter_map(|e| e.ok())
                        .filter_map(|e| {
                            let path = e.path();
                            if path.extension().and_then(|s| s.to_str()) == Some("mu") {
                                path.file_name()
                                    .and_then(|n| n.to_str())
                                    .map(|s| s.to_string())
                            } else {
                                None
                            }
                        })
                        .collect();
                    names.sort();
                    println!("[worlds]");
                    if names.is_empty() {
                        println!("  (no .mu files in mu_programs/)");
                    } else {
                        for name in names {
                            println!("  {name}");
                        }
                    }
                }
                Err(e) => {
                    println!("[worlds] error reading mu_programs/: {e}");
                }
            }
            continue;
        }

        // :doc-world NAME -> show markdown docs for that world
        if line.starts_with(":doc-world ") {
            let name = line[11..].trim();
            if name.is_empty() {
                println!("usage: :doc-world NAME");
                continue;
            }

            // You can change this path if you prefer another layout
            let path = format!("docs/worlds/{}.md", name);

            match fs::read_to_string(&path) {
                Ok(contents) => {
                    println!("[doc-world:{}]", name);
                    println!("{}", contents);
                }
                Err(e) => {
                    println!("[doc-world] could not read {}: {}", path, e);
                }
            }

            continue;
        }

        // :doc-gen NAME -> generate docs/worlds/NAME.auto.md from current rules
        if line.starts_with(":doc-gen ") {
            let name = line[9..].trim();
            if name.is_empty() {
                println!("usage: :doc-gen NAME");
                continue;
            }

            // Ensure docs/worlds/ exists
            if let Err(e) = std::fs::create_dir_all("docs/worlds") {
                println!("[doc-gen] could not create docs/worlds/ directory: {}", e);
                continue;
            }

            // We write to NAME.auto.md so it doesn't overwrite hand-written docs.
            let path = format!("docs/worlds/{}.auto.md", name);
            let contents = generate_world_doc(name, &program);

            match std::fs::write(&path, contents) {
                Ok(()) => {
                    println!(
                        "[doc-gen] wrote autogenerated doc for `{}` to {}",
                        name, path
                    );
                }
                Err(e) => {
                    println!("[doc-gen] error writing {}: {}", path, e);
                }
            }

            continue;
        }

        // :save-world NAME -> save current rules as mu_programs/NAME.mu
        if line.starts_with(":save-world ") {
            let name = line[12..].trim();
            if name.is_empty() {
                println!("usage: :save-world NAME");
                continue;
            }

            match save_mu_file(name, &program) {
                Ok(fname) => {
                    println!(
                        "[save-world] wrote {} rules to mu_programs/{}",
                        program.rules.len(),
                        fname
                    );
                }
                Err(e) => {
                    println!("[save-world] error: {e}");
                }
            }

            continue;
        }

        // :load-world NAME -> reset + load mu_programs/NAME.mu as the world
        if line.starts_with(":load-world ") {
            let name = line[12..].trim();
            if name.is_empty() {
                println!("usage: :load-world NAME");
                continue;
            }

            match load_mu_file(name) {
                Ok(p) => {
                    let count = p.rules.len();

                    // Replace the whole program with what we just loaded
                    program = p;
                    engine = Engine::new(program.clone());
                    state = RCXState::new();

                    // For display: normalize like :save-world
                    let display_name = if name.ends_with(".mu") {
                        name.to_string()
                    } else {
                        format!("{name}.mu")
                    };

                    println!(
                        "[load-world] loaded {count} rules from mu_programs/{} and reset state",
                        display_name
                    );
                }
                Err(e) => {
                    println!("[load-world] error: {e}");
                }
            }

            continue;
        }

        // :diff-world A B  -> compare two worlds' rule sets
        if line.starts_with(":diff-world ") {
            let rest = line[12..].trim();
            let parts: Vec<&str> = rest.split_whitespace().collect();
            if parts.len() != 2 {
                println!("usage: :diff-world WORLD_A WORLD_B");
                println!("  example: :diff-world rcx_core vars_demo");
                continue;
            }

            let a_name = parts[0];
            let b_name = parts[1];

            diff_worlds(a_name, b_name);
            continue;
        }

        // :merge-lobes -> move all lobes into r_a, logging trace events
        if line == ":merge-lobes" {
            if state.lobes.is_empty() {
                println!("[merge-lobes] no lobes to merge");
            } else {
                // Take ownership of the lobes first to avoid double mutable borrow.
                let drained: Vec<Mu> = state.lobes.drain(..).collect();
                let mut count = 0usize;

                for mu in drained {
                    let payload = mu.clone();
                    state.ra.push(mu);
                    state.log_event("merge_lobe_to_ra", RouteKind::Ra, payload);
                    count += 1;
                }

                println!("[merge-lobes] merged {count} lobe item(s) into r_a");
            }
            continue;
        }

        // :save-state NAME  -> snapshots/NAME.state
        if line.starts_with(":save-state ") {
            let name = line[12..].trim();
            if name.is_empty() {
                println!("usage: :save-state NAME");
                continue;
            }

            // Ensure snapshots/ exists
            if let Err(e) = std::fs::create_dir_all("snapshots") {
                println!("[save-state] could not create snapshots/ directory: {e}");
                continue;
            }

            let path = format!("snapshots/{}.state", name);

            match save_state(&path, &state, &program) {
                Ok(()) => {
                    println!(
                        "[save-state] wrote {} rules + buckets to {}",
                        program.rules.len(),
                        path
                    );
                }
                Err(e) => {
                    println!("[save-state] error: {e}");
                }
            }

            continue;
        }

        // :load-state NAME  -> snapshots/NAME.state
        if line.starts_with(":load-state ") {
            let name = line[12..].trim();
            if name.is_empty() {
                println!("usage: :load-state NAME");
                continue;
            }

            let path = format!("snapshots/{}.state", name);

            match load_state(&path) {
                Ok((new_state, new_program)) => {
                    state = new_state;
                    program = new_program;
                    // Rebuild engine so routing uses restored rules
                    engine = Engine::new(program.clone());

                    println!(
                        "[load-state] restored from {} (rules: {}, r_a: {}, lobes: {}, sink: {})",
                        path,
                        program.rules.len(),
                        state.ra.len(),
                        state.lobes.len(),
                        state.sink.len()
                    );
                }
                Err(e) => {
                    println!("[load-state] error: {e}");
                }
            }

            continue;
        }

        // :export-json NAME -> write rules to worlds_json/NAME.json
        if line.starts_with(":export-json ") {
            let name = line[13..].trim();
            if name.is_empty() {
                println!("usage: :export-json NAME");
                continue;
            }

            match serialize_json::export_world_json(name, &program) {
                Ok(path) => {
                    println!(
                        "[export-json] saved {} rules to {}",
                        program.rules.len(),
                        path
                    );
                }
                Err(e) => {
                    println!("[export-json] error: {e}");
                }
            }

            continue;
        }

        // :learn pattern rewrite target
        // :learn pattern ra|lobe|sink
        //
        // examples:
        //   :learn ping rewrite pong
        //   :learn [x,x] lobe
        if line.starts_with(":learn ") {
            let rest = line[7..].trim();
            if rest.is_empty() {
                println!("usage:");
                println!("  :learn MU rewrite MU");
                println!("  :learn MU {{ra|lobe|sink}}");
                continue;
            }

            let parts: Vec<&str> = rest.split_whitespace().collect();
            if parts.len() < 2 {
                println!("usage:");
                println!("  :learn MU rewrite MU");
                println!("  :learn MU {{ra|lobe|sink}}");
                continue;
            }

            // pattern
            let pat_src = parts[0];
            let pattern: Mu = match parse_mu(pat_src) {
                Ok(mu) => mu,
                Err(e) => {
                    println!("[learn] pattern parse error: {e}");
                    continue;
                }
            };

            if parts.len() == 2 {
                // bucket form: :learn MU bucket
                let target = parts[1].to_lowercase();
                let action = match target.as_str() {
                    "ra" => RuleAction::ToRa,
                    "lobe" | "lobes" => RuleAction::ToLobe,
                    "sink" => RuleAction::ToSink,
                    _ => {
                        println!(
                            "[learn] unknown target `{}` (use ra|lobe|sink or `rewrite`)",
                            target
                        );
                        continue;
                    }
                };

                program.rules.push(RcxRule { pattern, action });
                engine = Engine::new(program.clone());
                println!("[learn] rule added.");
                continue;
            }

            // at least 3 tokens: pattern keyword rhs...
            let keyword = parts[1].to_lowercase();
            if keyword == "rewrite" {
                if parts.len() < 3 {
                    println!("[learn] usage: :learn MU rewrite MU");
                    continue;
                }
                let rhs_src = parts[2];
                let rhs_mu: Mu = match parse_mu(rhs_src) {
                    Ok(mu) => mu,
                    Err(e) => {
                        println!("[learn] rewrite payload parse error: {e}");
                        continue;
                    }
                };
                let action = RuleAction::Rewrite(rhs_mu);
                program.rules.push(RcxRule { pattern, action });
                engine = Engine::new(program.clone());
                println!("[learn] rule added.");
                continue;
            }

            println!(
                "[learn] unknown directive `{}` (use rewrite|ra|lobe|sink)",
                keyword
            );
            continue;
        }

        // :orbit MU [n]
        if line.starts_with(":orbit") {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() < 2 {
                println!("usage: :orbit <Mu> [max_steps]");
                continue;
            }

            let mu_src = parts[1];
            let max_steps = if parts.len() >= 3 {
                parts[2].parse::<usize>().unwrap_or(12)
            } else {
                12
            };

            let seed = match parse_mu(mu_src) {
                Ok(mu) => mu,
                Err(e) => {
                    println!("[orbit] parse error: {e}");
                    continue;
                }
            };

            let seq = orbit(&program, seed.clone(), max_steps);
            println!("[ω] seed: {}", mu_to_string(&seed));
            println!(
                "[ω] orbit ({} states): {}",
                seq.len(),
                bucket_to_string(&seq)
            );
            continue;
        }

        // :omega MU [n]
        if line.starts_with(":omega") {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() < 2 {
                println!("usage: :omega <Mu> [max_steps]");
                continue;
            }

            let mu_src = parts[1];
            let max_steps = if parts.len() >= 3 {
                parts[2].parse::<usize>().unwrap_or(12)
            } else {
                12
            };

            let seed = match parse_mu(mu_src) {
                Ok(mu) => mu,
                Err(e) => {
                    println!("[ω] parse error: {e}");
                    continue;
                }
            };

            let seq = orbit(&program, seed.clone(), max_steps);
            let classification = classify_orbit(&seq);

            println!("[ω] seed: {}", mu_to_string(&seed));
            println!(
                "[ω] orbit ({} states): {}",
                seq.len(),
                bucket_to_string(&seq)
            );
            println!("[ω] classification: {}", classification);

            continue;
        }

        // --- Mu evaluation --------------------------------------------------

        match parse_mu(line) {
            Ok(mu) => {
                let route = engine.process_input(&mut state, mu);
                println!("→ route: {:?}", route);
                println!("  r_a:   {}", bucket_to_string(&state.ra));
                println!("  lobes: {}", bucket_to_string(&state.lobes));
                println!("  sink:  {}", bucket_to_string(&state.sink));
            }
            Err(err) => {
                println!("parse error: {err}");
            }
        }
    }
}
