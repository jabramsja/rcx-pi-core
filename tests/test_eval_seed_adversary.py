"""
Adversary Tests for EVAL_SEED

These tests were generated by the adversary agent to document edge cases
and prevent regression. They test attack vectors that were either:
- BLOCKED (proving guardrails work)
- PARTIAL (documenting known limitations)

See tools/agents/adversary_prompt.md for the adversary agent role.
"""

import pytest
import sys
from rcx_pi.eval_seed import match, substitute, apply_projection, step, NO_MATCH
from rcx_pi.mu_type import is_mu, assert_mu


# =============================================================================
# Deep Nesting Limits
# =============================================================================


class TestDeepNestingLimits:
    """Tests for deep nesting protection.

    PARTIAL CONCERN: Deep nesting can cause RecursionError.
    This is a DoS vector but not a security exploit.
    """

    def make_deep_nest(self, depth: int, value='bottom'):
        """Create a deeply nested structure."""
        result = value
        for _ in range(depth):
            result = {'nest': result}
        return result

    def test_moderate_nesting_works(self):
        """Moderate nesting (within MAX_MU_DEPTH) should work."""
        from rcx_pi.mu_type import MAX_MU_DEPTH

        # Use depth well within the limit
        depth = min(100, MAX_MU_DEPTH - 50)
        pattern = self.make_deep_nest(depth, {'var': 'x'})
        value = self.make_deep_nest(depth, 'found')

        result = match(pattern, value)
        assert result == {'x': 'found'}

    def test_deep_nesting_rejected_as_invalid_mu(self):
        """Deep nesting (beyond MAX_MU_DEPTH) is rejected as invalid Mu.

        The is_mu() function now has a depth limit (MAX_MU_DEPTH=200) to
        prevent RecursionError attacks. Values exceeding this depth are
        rejected with TypeError rather than crashing.
        """
        from rcx_pi.mu_type import MAX_MU_DEPTH

        pattern = self.make_deep_nest(MAX_MU_DEPTH + 50, {'var': 'x'})
        value = self.make_deep_nest(MAX_MU_DEPTH + 50, 'found')

        # Deep values are now rejected as invalid Mu (TypeError)
        with pytest.raises(TypeError) as exc_info:
            match(pattern, value)
        assert "must be a Mu" in str(exc_info.value)

    def test_substitute_deep_nesting_rejected_as_invalid_mu(self):
        """Deep nesting in substitute also rejected as invalid Mu."""
        from rcx_pi.mu_type import MAX_MU_DEPTH

        body = self.make_deep_nest(MAX_MU_DEPTH + 50, {'var': 'x'})
        bindings = {'x': 'replacement'}

        with pytest.raises(TypeError) as exc_info:
            substitute(body, bindings)
        assert "must be a Mu" in str(exc_info.value)


# =============================================================================
# Dict Subclass Isolation
# =============================================================================


class TestDictSubclassIsolation:
    """Tests for dict/list subclass rejection.

    HARDENED: Dict and list subclasses are now rejected by is_mu().
    This prevents side effects from custom __getitem__/__iter__ methods.
    """

    def test_dict_subclass_rejected_by_is_mu(self):
        """Dict subclasses are rejected to prevent side effect injection."""
        class SneakyDict(dict):
            pass

        # Subclasses are now rejected
        assert is_mu(SneakyDict({'a': 1})) is False

    def test_dict_subclass_side_effects_blocked(self):
        """Dict subclass side effects are blocked because match() uses assert_mu().

        The assert_mu() guard in match() rejects subclasses before any
        iteration occurs, preventing side effect execution.
        """
        effects = []

        class SideEffectDict(dict):
            def __getitem__(self, key):
                effects.append(f'get:{key}')
                return super().__getitem__(key)

        sd = SideEffectDict({'a': 1})

        # is_mu rejects the subclass
        assert is_mu(sd) is False

        # match() raises TypeError because assert_mu() rejects the subclass
        import pytest
        with pytest.raises(TypeError, match="must be a Mu"):
            match({'a': {'var': 'x'}}, sd)

        # No side effects occurred - the guard blocked iteration
        assert effects == []

    def test_list_subclass_rejected_by_is_mu(self):
        """List subclasses are rejected to prevent side effect injection."""
        class SneakyList(list):
            pass

        # Subclasses are now rejected
        assert is_mu(SneakyList([1, 2, 3])) is False

    def test_exact_dict_and_list_still_pass(self):
        """Exact dict and list types still pass is_mu."""
        assert is_mu({'a': 1}) is True
        assert is_mu([1, 2, 3]) is True
        assert is_mu({'nested': [1, {'x': 2}]}) is True


# =============================================================================
# Float Edge Cases
# =============================================================================


class TestFloatEdgeCases:
    """Tests for float handling edge cases."""

    def test_nan_rejected_by_assert_mu(self):
        """NaN is not valid Mu - rejected by assert_mu."""
        with pytest.raises(TypeError):
            assert_mu(float('nan'), 'test')

    def test_infinity_rejected_by_assert_mu(self):
        """Infinity is not valid Mu - rejected by assert_mu."""
        with pytest.raises(TypeError):
            assert_mu(float('inf'), 'test')

    def test_negative_infinity_rejected(self):
        """Negative infinity is also rejected."""
        with pytest.raises(TypeError):
            assert_mu(float('-inf'), 'test')

    def test_float_precision_no_coercion(self):
        """0.1 + 0.2 != 0.3 due to float precision (no forced equality)."""
        # This is Python's standard float behavior, not a bug
        result = match(0.3, 0.1 + 0.2)
        assert result is NO_MATCH

    def test_float_int_no_coercion(self):
        """1.0 does not match 1 (no type coercion)."""
        assert match(1.0, 1) is NO_MATCH
        assert match(1, 1.0) is NO_MATCH


# =============================================================================
# Bool/Int Coercion Prevention
# =============================================================================


class TestBoolIntCoercionPrevention:
    """Tests proving Python's True==1 coercion is blocked."""

    def test_true_does_not_match_1(self):
        """True does not match 1 (guardrail against Python coercion)."""
        assert match(True, 1) is NO_MATCH

    def test_1_does_not_match_true(self):
        """1 does not match True."""
        assert match(1, True) is NO_MATCH

    def test_false_does_not_match_0(self):
        """False does not match 0."""
        assert match(False, 0) is NO_MATCH

    def test_0_does_not_match_false(self):
        """0 does not match False."""
        assert match(0, False) is NO_MATCH

    def test_bool_in_list_no_coercion(self):
        """Coercion prevention works in nested structures."""
        assert match([True], [1]) is NO_MATCH
        assert match([1], [True]) is NO_MATCH

    def test_bool_in_dict_no_coercion(self):
        """Coercion prevention works in dict values."""
        assert match({'a': True}, {'a': 1}) is NO_MATCH
        assert match({'a': 1}, {'a': True}) is NO_MATCH


# =============================================================================
# Empty and Special Variable Names
# =============================================================================


class TestSpecialVariableNames:
    """Tests for edge case variable names."""

    def test_empty_string_var_name(self):
        """Empty string is a valid variable name."""
        result = match({'var': ''}, 42)
        assert result == {'': 42}

    def test_var_named_var(self):
        """'var' is a valid variable name (no collision)."""
        result = match({'var': 'var'}, 'test')
        assert result == {'var': 'test'}

    def test_var_named_pattern(self):
        """'pattern' is a valid variable name."""
        result = match({'var': 'pattern'}, 'test')
        assert result == {'pattern': 'test'}

    def test_var_named_body(self):
        """'body' is a valid variable name."""
        result = match({'var': 'body'}, 'test')
        assert result == {'body': 'test'}

    def test_python_keywords_as_var_names(self):
        """Python keywords work as variable names."""
        for name in ['None', 'True', 'False', 'class', 'def', 'return']:
            result = match({'var': name}, 'test')
            assert result == {name: 'test'}

    def test_dunder_var_names(self):
        """Dunder names work as variable names."""
        for name in ['__proto__', '__class__', '__init__']:
            result = match({'var': name}, 'test')
            assert result == {name: 'test'}

    def test_unicode_var_names(self):
        """Unicode variable names work."""
        for name in ['Œ±', 'ÂèòÈáè', 'üî•', '√ºber']:
            result = match({'var': name}, 'test')
            assert result == {name: 'test'}


# =============================================================================
# Y-Combinator Impossibility
# =============================================================================


class TestYCombinatorImpossibility:
    """Tests proving Y-combinator cannot be expressed.

    These tests demonstrate that projections are DATA, not callable
    functions. There is no way to "apply" a projection from within
    another projection - the kernel selects and applies projections,
    not the projections themselves.
    """

    def test_projection_is_inert_data(self):
        """A projection structure is just data, not executable."""
        proj_data = {'pattern': {'var': 'x'}, 'body': {'var': 'x'}}

        # It's valid Mu
        assert is_mu(proj_data)

        # But it's not callable
        assert not callable(proj_data)

    def test_projection_cannot_call_projection(self):
        """Projections cannot invoke other projections."""
        # A projection that copies its input twice
        proj = {
            'pattern': {'var': 'x'},
            'body': {'self': {'var': 'x'}, 'applied_to': {'var': 'x'}}
        }

        # Apply to projection-like data
        proj_data = {'pattern': 'p', 'body': 'b'}
        result = apply_projection(proj, proj_data)

        # The result just contains copies of the data
        # There's no way to "execute" the projection data
        assert result == {
            'self': {'pattern': 'p', 'body': 'b'},
            'applied_to': {'pattern': 'p', 'body': 'b'}
        }

        # The copies are still just data
        assert not callable(result['self'])

    def test_self_reference_impossible(self):
        """Variables cannot bind to the projection they're in."""
        # Try to create self-reference
        proj = {
            'pattern': {'var': 'self'},
            'body': {'result': {'var': 'self'}}
        }

        # Apply to any value
        result = apply_projection(proj, 'input')

        # 'self' binds to 'input', not to the projection
        assert result == {'result': 'input'}

    def test_no_delayed_evaluation(self):
        """Substitution is immediate, not delayed."""
        bindings = {'x': 42}
        body = {'outer': {'inner': {'var': 'x'}}}

        result = substitute(body, bindings)

        # All substitutions happen immediately
        assert result == {'outer': {'inner': 42}}
        # No thunks, no delayed computation


# =============================================================================
# Callable Injection Prevention
# =============================================================================


class TestCallableInjectionPrevention:
    """Tests for callable rejection."""

    def test_lambda_rejected(self):
        """Lambda functions are rejected."""
        with pytest.raises(TypeError):
            assert_mu(lambda x: x, 'test')

    def test_function_rejected(self):
        """Regular functions are rejected."""
        def my_func():
            pass
        with pytest.raises(TypeError):
            assert_mu(my_func, 'test')

    def test_callable_in_list_rejected(self):
        """Callables nested in lists are rejected."""
        with pytest.raises(TypeError):
            assert_mu([1, 2, lambda x: x], 'test')

    def test_callable_in_dict_rejected(self):
        """Callables nested in dicts are rejected."""
        with pytest.raises(TypeError):
            assert_mu({'a': 1, 'b': lambda x: x}, 'test')

    def test_class_rejected(self):
        """Classes are rejected (they're callable)."""
        class MyClass:
            pass
        with pytest.raises(TypeError):
            assert_mu(MyClass, 'test')


# =============================================================================
# Circular Reference Handling
# =============================================================================


class TestCircularReferenceHandling:
    """Tests for circular reference behavior."""

    def test_circular_dict_detected_gracefully(self):
        """Circular dict references are detected and rejected.

        Circular structures are not valid JSON and cannot be represented as Mu.
        is_mu() detects cycles and returns False instead of crashing.
        """
        circular = {'a': None}
        circular['a'] = circular

        # is_mu detects the cycle and returns False
        assert is_mu(circular) is False

    def test_circular_list_detected_gracefully(self):
        """Circular list references are detected and rejected."""
        circular = [1, 2, None]
        circular[2] = circular

        # is_mu detects the cycle and returns False
        assert is_mu(circular) is False

    def test_circular_dict_in_normalize_raises(self):
        """Circular dict in normalize_for_match raises ValueError.

        Defense-in-depth: even if is_mu check is bypassed, normalize
        detects cycles and raises rather than infinite looping.
        """
        from rcx_pi.match_mu import normalize_for_match

        circular = {'a': None}
        circular['a'] = circular

        with pytest.raises(ValueError, match="Circular reference"):
            normalize_for_match(circular)

    def test_circular_list_in_normalize_raises(self):
        """Circular list in normalize_for_match raises ValueError."""
        from rcx_pi.match_mu import normalize_for_match

        circular = [1, 2, None]
        circular[2] = circular

        with pytest.raises(ValueError, match="Circular reference"):
            normalize_for_match(circular)

    def test_circular_in_denormalize_raises(self):
        """Circular structure in denormalize_from_match raises ValueError.

        Defense-in-depth: if a circular structure somehow emerges during
        projection execution, denormalize detects it.
        """
        from rcx_pi.match_mu import denormalize_from_match

        # Create a circular linked list structure
        circular = {"head": 1, "tail": None}
        circular["tail"] = circular

        with pytest.raises(ValueError, match="Circular reference"):
            denormalize_from_match(circular)

    def test_circular_in_is_dict_linked_list_returns_false(self):
        """Circular structure in is_dict_linked_list returns False (not infinite loop).

        This function is called during denormalization to detect dict encodings.
        A circular structure should return False, not hang.
        """
        from rcx_pi.match_mu import is_dict_linked_list, is_kv_pair_linked

        # Create a circular linked list that looks like a dict encoding
        # Each element needs to look like a kv-pair for is_kv_pair_linked to pass
        kv_pair = {"head": "key", "tail": {"head": "value", "tail": None}}
        circular = {"head": kv_pair, "tail": None}
        circular["tail"] = circular  # Create cycle

        # Should return False (circular), not hang
        assert is_dict_linked_list(circular) is False

    def test_nested_circular_in_normalize_raises(self):
        """Circular reference nested inside a valid structure is detected."""
        from rcx_pi.match_mu import normalize_for_match

        # Circular dict nested inside a list
        circular = {'a': None}
        circular['a'] = circular
        nested = [1, 2, circular]

        with pytest.raises(ValueError, match="Circular reference"):
            normalize_for_match(nested)


# =============================================================================
# Determinism Verification
# =============================================================================


class TestDeterminismVerification:
    """Tests verifying deterministic behavior."""

    def test_match_is_deterministic(self):
        """match() returns same result on repeated calls."""
        pattern = {'a': {'var': 'x'}, 'b': {'var': 'y'}}
        value = {'a': 1, 'b': 2}

        results = [match(pattern, value) for _ in range(100)]

        # All results should be identical
        assert all(r == results[0] for r in results)

    def test_substitute_is_deterministic(self):
        """substitute() returns same result on repeated calls."""
        body = {'result': [{'var': 'x'}, {'var': 'y'}]}
        bindings = {'x': 'first', 'y': 'second'}

        results = [substitute(body, bindings) for _ in range(100)]

        assert all(r == results[0] for r in results)

    def test_step_is_deterministic(self):
        """step() returns same result on repeated calls."""
        projections = [
            {'pattern': {'type': 'a'}, 'body': 'matched_a'},
            {'pattern': {'type': 'b'}, 'body': 'matched_b'},
        ]
        value = {'type': 'b'}

        results = [step(projections, value) for _ in range(100)]

        assert all(r == results[0] for r in results)

    def test_dict_key_order_does_not_affect_match(self):
        """Dict key ordering doesn't affect match results."""
        import json

        # Create dicts with different insertion orders
        d1 = {'a': 1, 'b': 2, 'c': 3}
        d2 = {'c': 3, 'a': 1, 'b': 2}
        d3 = {'b': 2, 'c': 3, 'a': 1}

        pattern = {'a': {'var': 'x'}, 'b': {'var': 'y'}, 'c': {'var': 'z'}}

        r1 = match(pattern, d1)
        r2 = match(pattern, d2)
        r3 = match(pattern, d3)

        # All should produce equivalent bindings
        assert r1 == r2 == r3


# =============================================================================
# Non-Linear Pattern Matching
# =============================================================================


class TestNonLinearPatternMatching:
    """Tests for same variable appearing multiple times in pattern."""

    def test_same_var_twice_same_value_matches(self):
        """Same variable twice with same value should match."""
        pattern = [{'var': 'x'}, {'var': 'x'}]
        value = [42, 42]

        result = match(pattern, value)
        assert result == {'x': 42}

    def test_same_var_twice_different_value_fails(self):
        """Same variable twice with different values should fail."""
        pattern = [{'var': 'x'}, {'var': 'x'}]
        value = [42, 43]

        result = match(pattern, value)
        assert result is NO_MATCH

    def test_same_var_complex_value_structural_equality(self):
        """Complex values compared structurally for non-linear patterns."""
        pattern = [{'var': 'x'}, {'var': 'x'}]
        value = [{'a': [1, 2]}, {'a': [1, 2]}]

        result = match(pattern, value)
        assert result == {'x': {'a': [1, 2]}}

    def test_same_var_complex_value_different_fails(self):
        """Different complex values fail non-linear match."""
        pattern = [{'var': 'x'}, {'var': 'x'}]
        value = [{'a': [1, 2]}, {'a': [1, 3]}]

        result = match(pattern, value)
        assert result is NO_MATCH
